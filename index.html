<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Angular Signal Graph Visualizer</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    textarea {
      width: 100%;
      height: 200px;
      margin-bottom: 10px;
    }
    #graphContainer {
      border: 1px solid #ccc;
      width: 100%;
      height: 70vh;
      resize: vertical;
      overflow: hidden;
      position: relative;
    }
    svg {
      width: 100%;
      height: 100%;
      cursor: grab;
    }
    .node text {
      font-size: 12px;
      pointer-events: none;
    }
    .link {
      fill: none;
      stroke: #999;
      stroke-width: 1.5px;
      marker-end: url(#arrow);
    }
    #nodeInfo {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      background: #f9f9f9;
      white-space: pre-wrap;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>Signal Graph Visualizer</h1>
  <textarea id="jsonInput" placeholder="JSON hier eingeben..."></textarea>
  <button onclick="renderGraph()">Visualisieren</button>

  <div id="graphContainer">
    <svg id="graph"></svg>
  </div>

  <div id="nodeInfo">Klick auf einen Knoten, um den Wert anzuzeigen.</div>

  <script>
    const kindColors = {
      signal: "#ffcc00",
      effect: "#66ccff",
      computed: "#cc66ff",
      input: "#44dd88",
      output: "#ff6666",
      template: "#9999ff",
      default: "#aaaaaa"
    };

    function getKindColor(kind) {
      return kindColors[kind] || kindColors.default;
    }

    const jsonInput = document.getElementById("jsonInput");
    const graphContainer = document.getElementById("graphContainer");

    // Restore JSON and container height
    const saved = localStorage.getItem("signalGraphJSON");
    if (saved) jsonInput.value = saved;

    const savedHeight = localStorage.getItem("graphContainerHeight");
    if (savedHeight) {
      graphContainer.style.height = savedHeight;
    }

    jsonInput.addEventListener("input", () => {
      localStorage.setItem("signalGraphJSON", jsonInput.value);
    });

    const resizeObserver = new ResizeObserver(entries => {
      for (let entry of entries) {
        const height = entry.target.offsetHeight;
        localStorage.setItem("graphContainerHeight", height + "px");
      }
    });
    resizeObserver.observe(graphContainer);

    function renderGraph() {
      const raw = jsonInput.value;
      let data;
      try {
        data = JSON.parse(raw);
      } catch (e) {
        alert("UngÃ¼ltiges JSON!");
        return;
      }

      const nodes = data.nodes.map((d, i) => ({
        id: i,
        label: d.label,
        kind: d.kind,
        value: d.value
      }));

      const linksRaw = data.edges.map(d => ({
        source: d.producer,
        target: d.consumer
      }));

      const groupedLinks = {};
      linksRaw.forEach(link => {
        const key = `${link.source}->${link.target}`;
        if (!groupedLinks[key]) groupedLinks[key] = [];
        groupedLinks[key].push(link);
      });

      for (const key in groupedLinks) {
        const group = groupedLinks[key];
        const mid = (group.length - 1) / 2;
        group.forEach((link, i) => {
          link.curveOffset = (i - mid) * 30;
        });
      }

      const svg = d3.select("#graph");
      svg.selectAll("*").remove();
      const width = svg.node().clientWidth;
      const height = svg.node().clientHeight;

      const zoomGroup = svg.append("g");
      svg.call(d3.zoom()
        .scaleExtent([0.1, 3])
        .on("zoom", (event) => {
          zoomGroup.attr("transform", event.transform);
        }));

      svg.append("defs").append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 15)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#999");

      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(linksRaw).id(d => d.id).distance(200))
        .force("charge", d3.forceManyBody().strength(-300))
        .force("center", d3.forceCenter(width / 2, height / 2));

      const link = zoomGroup.append("g")
        .selectAll("path")
        .data(linksRaw)
        .join("path")
        .attr("class", "link")
        .attr("marker-end", "url(#arrow)");

      const node = zoomGroup.append("g")
        .selectAll("g")
        .data(nodes)
        .join("g")
        .attr("class", "node")
        .on("click", (event, d) => showNodeInfo(d))
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

      node.each(function(d) {
        const group = d3.select(this);
        const kindText = d.kind || "";
        const radius = Math.max(20, kindText.length * 4.5 + 10);

        group.append("circle")
          .attr("r", radius)
          .attr("fill", getKindColor(d.kind));

        group.append("text")
          .text(kindText)
          .attr("text-anchor", "middle")
          .attr("dy", 4)
          .attr("fill", "#000")
          .attr("font-weight", "bold");

        group.append("text")
          .text(d.label)
          .attr("dy", 4)
          .attr("x", radius + 5)
          .attr("fill", "#333");
      });

      simulation.on("tick", () => {
        link.attr("d", d => {
          const dx = d.target.x - d.source.x;
          const dy = d.target.y - d.source.y;
          const dr = Math.sqrt(dx * dx + dy * dy) + Math.abs(d.curveOffset);
          const curve = d.curveOffset >= 0 ? 1 : 0;
          return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,${curve} ${d.target.x},${d.target.y}`;
        });

        node.attr("transform", d => `translate(${d.x},${d.y})`);
      });

      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

      function showNodeInfo(node) {
        const info = document.getElementById('nodeInfo');
        if (node.value !== undefined) {
          info.textContent = JSON.stringify(node.value, null, 2);
        } else {
          info.textContent = "Kein Wert vorhanden.";
        }
      }
    }

    window.addEventListener("DOMContentLoaded", () => {
      if (jsonInput.value.trim()) {
        renderGraph();
      }
    });

    // Tastatur-Zoomsteuerung (Strg + / -)
    window.addEventListener("keydown", (e) => {
      if (e.ctrlKey && (e.key === "+" || e.key === "-" || e.key === "=")) {
        e.preventDefault();
        const svg = d3.select("#graph");
        const zoom = d3.zoomTransform(svg.node());
        const factor = e.key === "-" ? 1 / 1.2 : 1.2;
        const newZoom = zoom.k * factor;
        svg.transition().duration(200)
          .call(d3.zoom().scaleTo, newZoom);
      }
    });
  </script>
</body>
</html>
